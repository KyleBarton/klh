* KLH
** General Notes
*** Initial notes
Copied from a txt file jotted down on day 1
**** Desired features
- Portability
- First-class lang support
- Fast
- Interoperable
- Extensible
**** What is a text editor?
***** Takes a string of text, manipulates, saves
- provides tools to manipulate the text quickly
- Provides tools allowing for searching of the text quickly
- provides tools for navigating the text quickly
- provides a clipboard, ideally an interoperable one
- provides an API for text annotations (can be used to build libs for underline/bold/italics, and also code highlights/tips/autofills/etc)
- provides an API to intercept user commands
- provides an API to apply text manipulation
- provides an API to access clipboard
- provides an API to search function
- provides an API to navigate text
***** Project commander
Functionality that we like when coding, but aren't really the job of the text editor. Things like:
- Semantic search/replace (rename, code references, etc)
- Refactor commands (extract method/class/parameter, inline, etc)
- File search 
  - Ideally, integrated into the code project context with proper ignores
- Terminal integration
- Build command/runner
- "Vim-y" commands:
  - Record macros
  - Repeat commands
  - autoformat
***** On portability
****** Rough Portability Requirements
******* Graphically:
- Useable on a standard unix terminal emulator
- Has a GUI that makes things pretty when available
- Think about mouse integration here then
******* Operating system:
- If it runs x86, it should be good to go
******* Configuration
- Goal would be 1 file/dir, 1 configuration. Drop & run wherever
  - Much like .emacs, but ideally no `emacs.d/`
- There are questions about language/framework installations, other dependencies
- Can a 1 file/dir, 1 configuration format be extensible? VsCode/emacs comes close
******* The project commander 
- this needs to be portable to really make this awesome
***** On Language support
- Talks to the Project commander API and the text editor text API to read
- Talks to the text editor Annotations API for autoprompt/tips/highlights/etc
- Talks to the text editor text API to make changes based on user-prompted refactor commands
  - AAAACTUALLY maybe talk to the refactor API via Project commander
- Interacts with the Project Commander API
- Interacts with the view?
  -  No. Let's let the project commander and/or text editor API interact with the view
***** On the view
- We need a terminal implementation of the API, and then a GUI implementation
- Should be a separate API, but is it open? This may be only for the text editor/project commander
  - This would be a knock against it compared to vim though
  - But also would probably keep the extensions community cleaner/easier to maintain
***** On state
- DB rather than files; sqlite?

**** Architecture
We need some visuals here
**** Technology
***** Idea1: Rust
****** Pros:
- Have been wanting to learn
- Lower level, definitely portable, probably fastest/most efficient usage of resources
- No need to malloc my way to death
****** Cons:
- Newer language, support may waver in coming years
- I don't know rust, so getting started will be slower
***** Idea2: Python
****** Pros:
- I know python well, no ramp-up time
- Easy support for list manipulation, will probably make for clean code
- Can be compiled down to an executable* (* need to verify this)
****** Cons:
- Could potentially take a lot of mem/be slower
- Not 100% sure it's portable
***** Idea3: Javascript
- Ok this isn't a real idea, BUT if we keep our interfaces tight, we could potentially create a web implementation of the view,
  and an http implementation of the text editor API, potentially creating a collaborative version
**** Name
- CTE -- Composable Text Editor
  - A little too brain-injury-y
- TEPC -- Text Editor, Project Commander
  - Awkward and a mouthful
- LELE -- Little Editor that Lives Everywhere
  - Call out to the portability, better be able to deliver on that promise
- RAW -- reader and writer
  - Too generic, there are a few "raw"s in crates.io
- For now, KLH
- Kyle's Little Helper
*** Misc
TODO these are messy thoughts and need to be organized better
- Thinking about command auditability and programmatic manipulation, we should
  have an "actionsTaken" buffer of some sort -- literally records every keystroke,
  could even be a true buffer to the command processor. When the user "opens" the
  buffer, maybe we do something special, like copy to a "command snapshot" or
  something... how else can you get the size of the buffer? the command itself
  would change the outcome .... This needs more thought. What if you wanted to
  pause & play commands to the buffer? What about programmatic access? Do we have
  a stdin/stdout buffer model? hmmmm
** Research
*** Resources to read
**** TODO The Craft of Text Editing, Craig Kinseth
The Craft of Text Editing, or Emacs for the Modern World: http://www.finseth.com/craft/
Craig A. Finseth
**** DONE The Emacs Tutorial
**** TODO The Design of Everyday Things, Donald Norman
**** TODO Rustbook
*** Notes during research
**** The Craft of Text Editing
- "Second, the mind has expectations: it sees (and in general senses) what it
  expects to see. In extreme cases, if something totally unexpected happens, it
  can take many seconds for the mind to even recognize that there is an
  unexpected image, in addition to the time required to process the image and
  make a decision. Thus, it is important for the program to anticipate what the
  mind will expect to see and to arrange the display accordingly."
  - One conclusion to draw from this: unexpected errors should be handled in a
    very consistent manner. Red text/exclamation points, whatever. Some signal
    to the user such that, while the signal is well-recognized, it tells the
    user something unrecognized happened, and they cannot be on autopilot/flow
    state any longer
- On extensibility:
  - late binding of names to procedures through indirect calls, dynamic linking, or other techniques
  - retaining and using the symbol table information at run time so that the user can think of changes in terms of names, not addresses
  - internal error and consistency checking under program control so that users can be protected from their mistakes
  - the ability to add code to the executing editor
- At a certain point, I have to abstract into a custum editor language:
  "3.2.11
  Custom Editor Languages No traditional language (except perhaps for Common
  Lisp) offers complete support for text editing. The solution, used by
  virtually every implementation of Emacs-type text editors, as well as many
  implementations of other editors, is the creation of a custom editor language.

  An existing language -- very often C -- is selected. This language is used to
  write an interpreter for the custom editor language. The interpreter manages
  memory, handles display refresh, and in general provides all of the necessary
  utility functions. The editor language is then used to write the logic of all
  the user-visible commands.

  As the editor language is implemented using an interpreter, the command set is
  readily extensible. Also, because the editor language is designed around text
  editing, it can offer excellent text-handling power.

  The division of the programming tasks into two components provides an
  excellent base for supporting large projects. And, since the interpreter is
  usually implemented in a language such as C, the interpreter can be quite
  efficient.

  For these reasons, custom editor languages are the preferred method for implementing text editors."
- On marks:
  "There are two types of marks. They differ only in how they behave in the case that an insertion is made at the location of the mark. Normal marks move with the insertion. Thus, the newly inserted character will be just before the mark. Fixed marks remain in place: the newly inserted character will be just after the mark. An example of the difference is in the case where a command is to identify the characters that are inserted. The command merely needs to create both a fixed and a normal mark at the same place. After the insertion, the two marks will bracket the new characters."

